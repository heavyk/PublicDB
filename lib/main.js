// Generated by LiveScript 1.2.0
var slice;
slice = [].slice;
(function(){
  'use strict';
  var Foxx, ArangoDB, Actions, DB, ArangoDatabase, ArangoCollection, internal, Da_Funk, console, _, controller, BLUEPRINT_COLLECTION_NAME, Blueprint, Blueprints_repo, path, query, mun_query, bps_query, bp_query, parse_fqvn, get_bp, do_doc, set_paths, MUN_COLLECTION_NAME, Mun, Muns_repo, NoAdmin, userIsAdmin;
  Foxx = require('org/arangodb/foxx');
  ArangoDB = require("org/arangodb");
  Actions = require("org/arangodb/actions");
  DB = ArangoDB.db;
  ArangoDatabase = ArangoDB.ArangoDatabase, ArangoCollection = ArangoDB.ArangoCollection;
  internal = require('internal');
  Da_Funk = require('./lib/da_funk');
  console = require('console');
  _ = require('lodash');
  controller = new Foxx.Controller(applicationContext);
  BLUEPRINT_COLLECTION_NAME = applicationContext.collectionName('Blueprint');
  Blueprint = Foxx.Model.extend({}, {
    attributes: {
      persona: {
        type: 'string',
        required: true,
        description: "the user that created this blueprint"
      },
      encantador: {
        type: 'string',
        required: true,
        description: "the incantation of this blueprint"
      },
      incantation: {
        type: 'string',
        required: true,
        description: "the incantation of this blueprint"
      },
      version: {
        type: 'string',
        required: true,
        description: "the version of this blueprint"
      },
      type: {
        type: 'string',
        description: "the type of blueprint this is (Cardinal/Fixed/Mutable)"
      },
      layout: {
        type: 'object',
        required: true
      },
      quests: {
        type: 'object'
      },
      machina: {
        type: 'object',
        required: true
      },
      embodies: {
        type: 'object'
      },
      poetry: {
        type: 'object'
      },
      phrases: {
        type: 'object'
      },
      api: {
        type: 'object'
      }
    }
  });
  Blueprints_repo = Foxx.Repository.extend({
    all: function(){
      var arr;
      arr = this.collection
        ? this.collection.toArray()
        : [];
      return arr;
    },
    bp: function(id){
      return this.collection.document(id);
    }
  });
  path = controller.get('/_bp', function(req, res){
    if (req.params('reset')) {
      admin.reset(applicationContext);
      return res.json({
        success: true
      });
    } else {
      return res.json({
        success: false
      });
    }
  });
  path.queryParam('reset', {
    type: 'string',
    description: "reload the blueprints from the fs?"
  });
  path = controller.post('/_admin/reset', function(req, res){
    console.log("TODO: reset functionality");
    return res.json({
      success: true
    });
  });
  path = controller.get('/_bp/_', function(req, res){
    var bps;
    console.log("TODO: add version to the mix");
    bps = Blueprints.all();
    return res.json(bps);
  });
  query = "FOR m IN Mun\n	FILTER m.persona == @persona\n	RETURN m";
  mun_query = DB._createStatement({
    query: query
  });
  query = "FOR bp IN " + BLUEPRINT_COLLECTION_NAME + "\n	FILTER bp.incantation == @incantation\n	FILTER bp.version == '0.1.1'\n	SORT bp.version DESC\n	LIMIT 1\n	RETURN bp";
  bps_query = DB._createStatement({
    query: query
  });
  query = "FOR bp IN " + BLUEPRINT_COLLECTION_NAME + "\n	FILTER bp.encantador == @encantador\n	FILTER bp.incantation == @incantation\n	SORT bp.version DESC\n	LIMIT 1\n	RETURN bp";
  bp_query = DB._createStatement({
    query: query
  });
  parse_fqvn = function(fqvn){
    var idx, incantation, encantador, ret, version;
    if (~(idx = fqvn.indexOf(':'))) {
      incantation = fqvn.substr(idx + 1);
      encantador = fqvn.substr(0, idx);
    } else {
      encantador = 'Word';
      incantation = fqvn;
    }
    ret = {
      encantador: encantador,
      incantation: incantation
    };
    if (~(idx = incantation.indexOf('@'))) {
      ret.version = version = incantation.substr(idx + 1);
      ret.incantation = incantation.substr(0, idx);
    }
    return ret;
  };
  get_bp = function(encantador, incantation, version){
    var ref$, idx, bp;
    if (typeof encantador === 'object') {
      ref$ = encantador, encantador = ref$.encantador, incantation = ref$.incantation, version = ref$.version;
    }
    if (~(idx = incantation.indexOf('@'))) {
      version = incantation.substr(idx + 1);
      incantation = incantation.substr(0, idx);
    }
    if (version && version !== 'latest') {
      bp = Blueprint_collection.byExample({
        encantador: encantador,
        incantation: incantation,
        version: version
      });
    } else {
      bp_query.bind('encantador', encantador);
      bp_query.bind('incantation', incantation);
      bp = bp_query.execute();
    }
    return bp.next();
  };
  do_doc = function(incantation, req){
    var bp, _doc, exp, get;
    console.log("incantation", incantation);
    bp = Da_Funk.da_funkiest(get_bp('Voice', incantation));
    _doc = req.body();
    if (typeof (exp = bp.experience) !== 'undefined' && typeof exp.have === 'function') {
      import$(_doc, exp.have.call(this, DB, req));
    }
    get = function(path, no_default){
      var v, s;
      if (typeof (v = ~path.indexOf('.')
        ? get_path(_doc, path)
        : _doc[path]) === 'undefined' && !no_default && typeof (s = bp.layout[path]) !== 'undefined') {
        if (typeof (v = s['default']) === 'function') {
          console.log("calling default:", s['default.js']);
          v = v.call({
            get: get
          }, s);
        }
      }
      return v;
    };
    _.each(bp.layout, function(v, k){
      if (v.required) {
        _doc[k] = get(k);
      }
    });
    console.log("doc:", JSON.stringify(_doc));
    return _doc;
  };
  path = controller.post('/_/:blueprint/', function(req, res){
    var blueprint, body, quest, fqvn, _bp, cid, cursor, e, q, _q, many, bindvars, ret, hasCount, count, rows, hasNext, cursorId, extra, result, code;
    blueprint = req.params('blueprint');
    body = Actions.getJsonBody(req, res);
    quest = body.quest;
    fqvn = parse_fqvn(blueprint);
    _bp = get_bp(fqvn);
    console.log(typeof _bp, JSON.stringify(fqvn));
    console.log("quest:", quest);
    console.log("user:", JSON.stringify(req.user));
    if (!_bp) {
      res.status(402);
      res.json({
        code: 'ENOENT'
      });
      return;
    } else if (cid = body.cursor) {
      console.log("get more on cursor: " + cid);
      try {
        cursor = CURSOR(cid);
      } catch (e$) {
        e = e$;
        res.status(403);
        res.json({
          code: 'EXPIRED'
        });
        return;
      }
    } else if (!_bp.quests || typeof quest !== 'string' || typeof (q = _bp.quests[quest]) !== 'object') {
      res.status(404);
      res.json({
        code: 'ENOQUESTS'
      });
      return;
    } else if (q) {
      _q = Da_Funk.da_funk(q);
      if (body.many) {
        many = body.many;
        delete body.many;
      } else {
        many = 10;
      }
      bindvars = import$(q.bindvars || {}, body);
      console.log("body", JSON.stringify(body));
      console.log("inquiry", q.inquiry);
      console.log("q.have", typeof _q.have);
      if (typeof _q.have === 'function') {
        switch (typeof (ret = _q.have(DB, req, res))) {
        case 'object':
          console.log("merging...", JSON.stringify(ret));
          import$(bindvars, ret);
        }
      }
      delete bindvars.quest;
      console.log("bindvars", JSON.stringify(bindvars));
      cursor = internal.AQL_QUERY(q.inquiry, bindvars, {
        count: true,
        batchSize: many
      }, {});
    } else {
      res.status(502);
      res.json({
        code: 'ECONFUSED'
      });
    }
    if (Array.isArray(cursor)) {
      hasCount = true;
      count = cursor.length;
      rows = cursor;
      hasNext = false;
      cursorId = null;
    } else if (typeof cursor === 'object') {
      if (typeof cursor.getExtra !== 'undefined') {
        hasCount = cursor.hasCount();
        count = cursor.count();
        rows = cursor.toArray();
        hasNext = cursor.hasNext();
        extra = cursor.getExtra();
        if (hasNext) {
          cursor.persist();
          cursorId = cursor.id();
        } else {
          cursorId = null;
          cursor.dispose();
        }
      } else if (cursor.hasOwnProperty('docs')) {
        hasCount = true;
        count = cursor.docs.length;
        rows = cursor.docs;
        extra = cursor.extra;
        hasNext = false;
        cursorId = null;
      }
    }
    result = {
      result: rows,
      hasMore: hasNext
    };
    if (cursorId) {
      result.id = cursorId;
    }
    if (hasCount) {
      result.count = count;
    }
    if (typeof extra !== 'undefined' && Object.keys(extra).length > 0) {
      result.extra = extra;
    }
    if (typeof code === 'undefined') {
      code = 'created';
    }
    res.json(result);
    cursor = null;
    internal.wait(0);
  });
  path.pathParam('blueprint', {
    type: 'string',
    description: "what Blueprint?"
  });
  path = controller.post('/_deps', function(req, res){
    var bps;
    console.log("TODO: get all of the deps here... this will be an array");
    bps_query.bind('incantation', ['ProfileComments', 'Mun']);
    bps = bp_query.execute();
    return res.json(bps.toArray());
  });
  path = controller.get('/_bp/:encantador/:incantation', function(req, res){
    var b;
    console.log("get_bp", req.params('encantador'), req.params('incantation'), req.params('version'));
    if (b = get_bp(req.params('encantador'), req.params('incantation'), req.params('version'))) {
      return res.json(b);
    } else {
      res.status(404);
      return res.json({
        code: 'ENOENT'
      });
    }
  });
  path.pathParam('encantador', {
    type: 'string',
    description: "what is the encantador (the machina which gives this life) of this blueprint"
  });
  path.pathParam('incantation', {
    type: 'string',
    description: "what is the name (incantation) of this blueprint"
  });
  path.queryParam('version', {
    type: 'string',
    description: "what id you want to get"
  });
  path = controller.del('/_bp/:id', function(req, res){
    var bp;
    return bp = Blueprint.removeById(req.params('id'));
  });
  path.pathParam('id', {
    type: 'string',
    description: "what id you want to delete"
  });
  path.onlyIfAuthenticated(401, 'not logged in');
  path = controller.patch('/_bp/:id', function(req, res){
    bps.removeById(req.params('id'));
    return res.json(bp.forClient());
  });
  path.pathParam('id', {
    type: 'string',
    description: "what id you want to get"
  });
  path.bodyParam('data', "new data for your Blueprint", Blueprint);
  path.onlyIfAuthenticated(401, 'not logged in');
  set_paths = [];
  _.each(Blueprints.all(), function(bp){
    var _bp, incantation, encantador, collection, e, layout, model, path, api, i$, ref$, len$, method;
    _bp = Da_Funk.da_funk(bp);
    incantation = _bp.incantation;
    encantador = _bp.encantador;
    if (_bp.type === 'Fixed' && _bp.presence !== 'Abstract' && !(collection = controller.collection(incantation))) {
      console.log("creating collection for: " + bp.encantador + "/" + bp.incantation, incantation);
      try {
        collection = controller.collection(incantation);
      } catch (e$) {
        e = e$;
        collection = DB._create(applicationContext.collectionName(incantation));
      }
    }
    if (layout = _bp.layout && !~set_paths.indexOf(incantation)) {
      set_paths.push(incantation);
      model = Foxx.Model.extend({}, _bp.layout);
      console.log("setting path: /" + incantation + "/:id");
      path = controller.get("/" + incantation + "/:id", function(req, res){
        var doc, e;
        console.log("got path", req.url);
        try {
          doc = controller.document(incantation + '/' + req.params('id'));
        } catch (e$) {
          e = e$;
          res.status(404);
          res.json({
            code: 'ENOENT'
          });
        }
        return res.json(doc);
      });
      path.pathParam('id', {
        type: 'string',
        description: "what id you want to get"
      });
      path = controller.del("/" + incantation + "/:id", function(req, res){
        var id;
        id = req.params('id');
        console.log("deleting: " + id);
        return res.json(controller.remove(incantation + '/' + id));
      });
      path.pathParam('id', {
        type: 'string',
        description: "what id you want to delete"
      });
      path = controller.patch("/" + incantation + "/:id", function(req, res){
        return res.json(controller.update(incantation + '/' + req.params('id')));
      });
      path.pathParam('id', {
        type: 'string',
        description: "what id you want to get"
      });
      path.bodyParam('data', "new data for your Blueprint", Blueprint);
      path = controller.post("/" + incantation, function(req, res){
        var doc, r;
        doc = do_doc(incantation, req);
        r = collection.save(doc);
        console.log("saving " + incantation + " -> " + r._key);
        return res.json(r);
      });
      path = controller.put("/" + incantation, function(req, res){
        var doc;
        doc = do_doc(incantation, req);
        console.log("replace " + incantation + " -> " + doc._key);
        return res.json(controller.replace(incantation + '/' + req.params('id'), req.body()));
      });
      path.bodyParam('incantation', "the incantation of your Blueprint", Blueprint);
      path.bodyParam('persona', "the owner of this Blueprint", Blueprint);
    }
    if (typeof _bp.api === 'function') {
      api = {};
      for (i$ = 0, len$ = (ref$ = ['get', 'del', 'delete', 'put', 'post', 'patch', 'head', 'before', 'after']).length; i$ < len$; ++i$) {
        method = ref$[i$];
        api[method] = fn$;
      }
      return _bp.api.call(bp, api, app);
    }
    function fn$(path, cb){
      return app[method].call(this, '/' + incantation + path, cb);
    }
  });
  MUN_COLLECTION_NAME = applicationContext.collectionName('Mun');
  Mun = Foxx.Model.extend({}, {
    attributes: {
      persona: {
        type: 'string',
        required: true
      },
      incantation: {
        type: 'string',
        required: true
      },
      foto: {
        type: 'string'
      },
      active: {
        type: 'boolean',
        defaultValue: true
      }
    }
  });
  Muns_repo = Foxx.Repository.extend({
    all: function(persona){
      var qry;
      qry = this.collection.byExample({
        uid: uid
      });
      return {
        muns: qry.toArray(),
        count: qry.count()
      };
    }
  });
  path = controller.get('/mun/_', function(req, res){
    var muns;
    muns = Muns.all(req.user._key);
    return res.json(muns);
  });
  path.onlyIfAuthenticated(401, 'not logged in');
  path = controller.get('/mun/:id', function(req, res){
    var mun;
    mun = Mun.byId(req.params('id'));
    return res.json(mun.forClient());
  });
  path.pathParam('id', {
    type: 'string',
    description: "what id you want to get"
  });
  path.onlyIfAuthenticated(401, 'not logged in');
  path = controller.get('/mun/:id', function(req, res){
    var mun;
    mun = Mun.byId(req.params('id'));
    return res.json(mun.forClient());
  });
  path.pathParam('id', {
    type: 'string',
    description: "what id you want to get"
  });
  path.onlyIfAuthenticated(401, 'not logged in');
  path = controller.del('/mun/:id', function(req, res){
    var mun;
    mun = Mun.removeById(req.params('id'));
    return console.log("remove mun:", mun);
  });
  path.pathParam('id', {
    type: 'string',
    description: "what id you want to get"
  });
  path.onlyIfAuthenticated(401, 'not logged in');
  path = controller.patch('/mun/:id', function(req, res){
    muns.removeById(req.params('id'));
    return res.json(mun.forClient());
  });
  path.pathParam('id', {
    type: 'string',
    description: "what id you want to get"
  });
  path.bodyParam('incantation', "new incantation for your Mun", Mun);
  path.onlyIfAuthenticated(401, 'not logged in');
  path = controller.put('/mun', function(req, res){
    var mun;
    mun = new Mun(req.body());
    return res.json(Muns.save(mun));
  });
  path.bodyParam('incantation', "the incantation of your Mun", Mun);
  path.bodyParam('uid', "the owner of this Mun", Mun);
  path.onlyIfAuthenticated(401, 'not logged in');
  NoAdmin = function(){};
  userIsAdmin = function(req){
    if (!(req.user && req.user.data.admin)) {
      throw new NoAdmin;
    }
  };
  NoAdmin.prototype = new Error;
  controller.activateAuthentication({
    type: 'cookie',
    cookieName: 'sessid',
    cookieLifetime: 360000,
    sessionLifetime: 600
  });
  controller.login('/login', {
    onSuccess: function(req, res){
      var mid, mun;
      req.currentSession.set('poem', 'Affinaty');
      console.log("login mun:", req.user.data.mun, req.user._key);
      if (!(mid = req.user.data.mun) && (mun = Mun_collection.firstExample({
        uid: req.user._key
      }))) {
        console.log("finding a mun:");
        console.dir(mun);
        req.currentSession.set('mun', mid = mun._key);
      }
      return res.json({
        msg: 'Logged in!',
        ident: req.user.identifier,
        persona: req.user._key,
        key: req.currentSession._key,
        now: req.currentSession.data,
        mun: mun
      });
    }
  });
  path = controller.post('/whoami', function(req, res){
    var mun, mid;
    console.log("WHOAMI", req.body().mun);
    if (mun = Mun_collection.firstExample({
      persona: req.user._key,
      _key: req.body().mun
    })) {
      console.log("found!", mun._key);
      req.currentSession.set('mun', mid = mun._key);
    }
    return res.json(req.currentSession.data);
  });
  path.onlyIfAuthenticated(401, 'not logged in');
  controller.logout('/logout');
  path = controller.get('/whoami', function(req, res){
    return res.json({
      ident: req.user.identifier,
      persona: req.user._key,
      key: req.currentSession._key,
      now: req.currentSession.data
    });
  });
  path.onlyIfAuthenticated(401, 'not logged in');
  controller.register('/register', {
    acceptedAttributes: ['incantation', 'full_incantation'],
    defaultAttributes: {
      admin: false,
      poem: 'affinaty'
    },
    onSuccess: function(req, res){
      var mid, mun;
      console.log("trying to register");
      if (!(mid = req.user.data.mun) && (mun = Mun_collection.firstExample({
        uid: req.user._key
      }))) {
        console.log("finding a mun:");
        console.dir(mun);
        req.currentSession.set('mun', mid = mun._key);
      }
      return res.json({
        ident: req.user.identifier,
        persona: req.user._key,
        key: req.currentSession._key,
        now: req.currentSession.data,
        mun: req.currentSession.data.mun
      });
    }
  });
  return console.log("mounted paths " + applicationContext.foxxes);
})();
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}